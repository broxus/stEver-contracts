pragma ever-solidity >= 0.62.0;

import "@broxus/contracts/contracts/access/InternalOwner.tsol";
import "@broxus/contracts/contracts/utils/RandomNonce.tsol";

import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import {PoolOfChanceGas} from "../utils/Gas.tsol";
import {ErrorCodesPoolOfChance} from "../utils/ErrorCodes.tsol";
import {PrizeTokenRewardType} from "../utils/Constants.tsol";

import "broxus-ton-tokens-contracts/contracts/interfaces/ITokenWallet.tsol";

import {IPoolOfChance} from "../interfaces/IPoolOfChance.tsol";
import {IStEverVault} from "../interfaces/IStEverVault.tsol";

abstract contract PoolOfChanceBase is
    RandomNonce,
    InternalOwner,
    IPoolOfChance
{
    uint128 constant DENOMINATOR = 1000000;
    uint128 constant MAX_POOL_CAPACITY = 10000; // active + inactive deposits

    address static poolFactory;

    address stEverVault;

    address stEverWallet; // StEver wallet address
    address stTokenRoot; // StToken root address
    address prizeTokenWallet; // Prize token wallet address
    address prizeTokenRoot; // Prize token root address

    uint32 depositsAmountForReward;

    uint128 everReserves; // Ever reserves for deposits and reward payout
    uint128 totalSupply; // sum of all Ever deposits
    uint128 totalStSupply; // StEver balance
    uint128 totalPrizeTokenSupply; // Prize token root balance

    uint128 minDepositValueForReward;
    uint128 minDepositValue;

    uint128 rewardTimestamp;
    uint32 rewardPeriod;

    uint128 fundFeeNumerator;
    uint128 poolFeeNumerator;
    address fundAddress;
    address poolFeeReceiverAddress;

    uint8 prizeTokenRewardType;
    optional(uint128) prizeTokenRewardValue;
    uint128 prizeTokenNoRewardValue;

    uint128 withdrawFee;

    mapping(address => uint128) depositsData; // user -> Ever deposit
    mapping(uint64 => address) pendingDeposits; // nonce -> user

    bool isLocked;

    address tempRemainingGasTo;
    DepositAndRewardStats stats;

    modifier reserve() {
        tvm.rawReserve(everReserves + PoolOfChanceGas.POOL_MIN_BALANCE, 0);
        _;
    }

    modifier onlyOwnerOrSelf() {
        require(
            msg.sender.value != 0 && (msg.sender == owner || msg.sender == address(this)),
            ErrorCodesPoolOfChance.NOT_OWNER_OR_SELF
        );
        _;
    }

    modifier notLocked() {
        require(!isLocked, ErrorCodesPoolOfChance.LOCKED);
        _;
    }

    modifier locked() {
        require(isLocked, ErrorCodesPoolOfChance.NOT_LOCKED);
        _;
    }

    receive() external pure {
        revert();
    }

    function onTokenWallet(address _wallet) external reserve() {
        require (msg.sender == stTokenRoot || msg.sender == prizeTokenRoot, ErrorCodesPoolOfChance.NOT_TOKEN_ROOT);

        if (msg.sender == stTokenRoot) {
            stEverWallet = _wallet;
        } else {
            prizeTokenWallet = _wallet;
        }
    }


    function getDepositData(address user) override responsible external returns(DepositData) {
        DepositData data;
        if (depositsData.exists(user)) {
            data.deposit = depositsData[user];
        }
        if (stats.rewardAssignee == user) {
            data.reward = stats.reward;
        }
        return {value:0, flag: MsgFlag.REMAINING_GAS, bounce: false} data;
    }

    function getActiveDepositsAmount() override responsible external returns(uint128) {
        return {value:0, flag: MsgFlag.REMAINING_GAS, bounce: false} stats.activeDepositsAmount;
    }

    function getPoolFeeReceiverAddress() override responsible external returns(address) {
        return {value:0, flag: MsgFlag.REMAINING_GAS, bounce: false} poolFeeReceiverAddress;
    }

    function getFundAddress() override responsible external returns(address) {
        return {value:0, flag: MsgFlag.REMAINING_GAS, bounce: false} fundAddress;
    }

    function getPoolInfo() override responsible external returns(PoolInfo) {
        return {value:0, flag: MsgFlag.REMAINING_GAS, bounce: false} PoolInfo(
            owner,
            poolFactory,
            stEverVault,
            everReserves,
            totalSupply,
            stTokenRoot,
            totalStSupply,
            prizeTokenRoot,
            totalPrizeTokenSupply,
            minDepositValue,
            withdrawFee
        );
    }

    function getRewardInfo() override responsible external returns(IPoolOfChance.RewardInfo) {
        return {value:0, flag: MsgFlag.REMAINING_GAS, bounce: false} RewardInfo(
            minDepositValueForReward,
            rewardPeriod,
            rewardTimestamp,
            poolFeeNumerator,
            fundFeeNumerator,
            depositsAmountForReward,
            prizeTokenRewardType,
            prizeTokenRewardValue,
            prizeTokenNoRewardValue
        );
    }

    function isPoolLocked() override responsible external returns(bool) {
        return {value:0, flag: MsgFlag.REMAINING_GAS, bounce: false} isLocked;
    }


    function setPoolFeeReceiverAddress(address _poolFeeReceiver) override external onlyOwner reserve() {
        emit UpdatePoolFeeReceiverAddress(_poolFeeReceiver, poolFeeReceiverAddress);
        poolFeeReceiverAddress = _poolFeeReceiver;
    }

    function setFundAddress(address _fundAddress) override external onlyOwner reserve() {
        emit UpdateFundAddress(fundAddress, _fundAddress);
        fundAddress = _fundAddress;
    }

    function addToEverReserves(uint128 _amount) override external {
        require(
            msg.value >= _amount + PoolOfChanceGas.ADD_TO_RESERVES_VALUE,
            ErrorCodesPoolOfChance.NOT_ENOUGH_VALUE
        );

        everReserves += _amount;

        tvm.rawReserve(everReserves + PoolOfChanceGas.POOL_MIN_BALANCE, 0);

        emit EverReservesSync(everReserves);

        msg.sender.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS,
            bounce: false
        });
    }

    function _calcRemainingAssets() internal view returns(uint128, uint128) {
        uint128 everWithdrawal = 0;
        uint128 prizeTokenWithdrawal = 0;

        uint128 reward;
        if (stats.rewardAssignee.value != 0) {

            reward = (stats.activeDepositsAmount - 1) * prizeTokenNoRewardValue;

            if (prizeTokenRewardType == PrizeTokenRewardType.EQUAL_TO_EVER_REWARD) {
                reward += stats.reward;
            } else {
                reward += prizeTokenRewardValue.get();
            }
        }

        uint128 reservesInUse =
            totalSupply + stats.reward -
            (stats.activeDepositsAmount + stats.inactiveDepositsAmount) * withdrawFee +
            stats.accFundFee + stats.accPoolFee;

        if (reward < totalPrizeTokenSupply) {
            prizeTokenWithdrawal = totalPrizeTokenSupply - reward;
        }
        if (reservesInUse < everReserves) {
            everWithdrawal = everReserves - reservesInUse;
        }

        return (everWithdrawal, prizeTokenWithdrawal);
    }

    function _withdrawPrizeTokenAssets(
        uint128 _withdrawal,
        address _remainingGasTo,
        uint16 _flag
    ) internal {
        totalPrizeTokenSupply -= _withdrawal;

        emit PrizeTokenReservesSync(totalPrizeTokenSupply);

        TvmCell empty;
        ITokenWallet(prizeTokenWallet)
            .transfer{
                value: PoolOfChanceGas.TRANSFER_VALUE,
                flag: _flag
            }(
            _withdrawal,
            owner,
            PoolOfChanceGas.WALLET_DEPLOY_GRAMS_VALUE,
            _remainingGasTo,
            true,
            empty
        );
    }

    function withdrawAllAssets()
        override
        external
        onlyOwnerOrSelf
        locked
    {
        (uint128 everWithdrawal, uint128 prizeTokenWithdrawal) = _calcRemainingAssets();

        address _remainingGasTo = msg.sender == owner ? owner : tempRemainingGasTo;

        if (prizeTokenWithdrawal > 0) {
            _withdrawPrizeTokenAssets(
                prizeTokenWithdrawal,
                _remainingGasTo,
                MsgFlag.SENDER_PAYS_FEES
            );
        }

        if (totalStSupply > 0) {
            _withdrawStAssets(_remainingGasTo, MsgFlag.SENDER_PAYS_FEES);
        }

        if (everWithdrawal > 0) {
            owner.transfer({
                value: everWithdrawal,
                flag: MsgFlag.SENDER_PAYS_FEES,
                bounce: false
            });
        }
        everReserves -= everWithdrawal;

        tvm.rawReserve(everReserves + PoolOfChanceGas.POOL_MIN_BALANCE, 0);

        _remainingGasTo.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS,
            bounce: false
        });
    }

    function withdrawPrizeTokenAssets()
        override
        external
        onlyOwner
        reserve()
        locked
    {
        (, uint128 withdrawal) = _calcRemainingAssets();
        require(withdrawal > 0, ErrorCodesPoolOfChance.NOT_ENOUGH_FUNDS);

        _withdrawPrizeTokenAssets(withdrawal, owner, MsgFlag.ALL_NOT_RESERVED);
    }

    function _withdrawStAssets(
        address _remainingGasTo,
        uint16 _flag
    ) internal {
        TvmCell empty;
        ITokenWallet(stEverWallet)
            .transfer{
                value: PoolOfChanceGas.TRANSFER_VALUE,
                flag: _flag
            }(
            totalStSupply,
            owner,
            PoolOfChanceGas.WALLET_DEPLOY_GRAMS_VALUE,
            _remainingGasTo,
            true,
            empty
        );

        totalStSupply = 0;
    }

    function withdrawRemainingStAssets()
        override
        external
        onlyOwner
        locked
        reserve()
    {
        require(totalStSupply > 0, ErrorCodesPoolOfChance.NOT_ENOUGH_FUNDS);

        _withdrawStAssets(owner, MsgFlag.ALL_NOT_RESERVED);
    }

    function withdrawRemainingAssets()
        override
        external
        onlyOwner
        locked
    {
        (uint128 withdrawal,) = _calcRemainingAssets();
        require(withdrawal > 0, ErrorCodesPoolOfChance.NOT_ENOUGH_FUNDS);

        everReserves -= withdrawal;

        tvm.rawReserve(everReserves + PoolOfChanceGas.POOL_MIN_BALANCE, 0);

        emit EverReservesSync(everReserves);

        owner.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED,
            bounce: false
        });
    }

    function withdrawFees()
        override
        external
        onlyOwner
    {
        require(msg.value >= PoolOfChanceGas.WITHDRAW_VALUE, ErrorCodesPoolOfChance.NOT_ENOUGH_VALUE);
        require(everReserves >= stats.accFundFee + stats.accPoolFee, ErrorCodesPoolOfChance.NOT_ENOUGH_FUNDS);
        require(poolFeeReceiverAddress.value != 0 && fundAddress.value != 0, ErrorCodesPoolOfChance.WRONG_ADDRESS);

        everReserves -= stats.accFundFee + stats.accPoolFee;

        tvm.rawReserve(everReserves + PoolOfChanceGas.POOL_MIN_BALANCE, 0);

        if (stats.accPoolFee > 0) {
            poolFeeReceiverAddress.transfer({
                value: stats.accPoolFee,
                flag: MsgFlag.SENDER_PAYS_FEES,
                bounce: false
            });

            stats.accPoolFee = 0;
        }

        if (stats.accFundFee > 0) {
            fundAddress.transfer({
                value: stats.accFundFee,
                flag: MsgFlag.SENDER_PAYS_FEES,
                bounce: false
            });

            stats.accFundFee = 0;
        }

        owner.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS,
            bounce: false
        });
    }

    function _getEverAmountFor(uint128 _amount, IStEverVault.Details _details) internal view returns(uint128) {
        if(_details.stEverSupply == 0 || _details.totalAssets == 0) {
            return _amount;
        }
        (,,uint128 _effectiveEverAssets) = _getLockStateFor(_details);
        return math.muldiv(_amount, _effectiveEverAssets, _details.stEverSupply);
    }

    function _getStEverAmountFor(uint128 _amount, IStEverVault.Details _details) internal view returns(uint128) {
        if(_details.stEverSupply == 0 || _details.totalAssets == 0) {
            return _amount;
        }
        (,,uint128 _effectiveEverAssets) = _getLockStateFor(_details);
        return math.muldiv(_amount, _details.stEverSupply, _effectiveEverAssets);
    }

    function _getLockStateFor(IStEverVault.Details _details) internal view returns (
        uint128 _remainingLockedAssets,
        uint128 _remainingSeconds,
        uint128 _effectiveEverAssets
    ) {
        uint128 timeFromLastUnlock = rewardTimestamp >= _details.lastUnlockTime
        ? rewardTimestamp - _details.lastUnlockTime : 0;
        uint128 unlockAmount = _details.unlockPerSecond * timeFromLastUnlock;
        _remainingLockedAssets = _details.remainingLockedAssets > unlockAmount
        ? _details.remainingLockedAssets - unlockAmount
        : 0;
        _remainingSeconds = _details.remainingSeconds > timeFromLastUnlock
        ? _details.remainingSeconds - timeFromLastUnlock
        : 0;
        _effectiveEverAssets = _details.totalAssets - _remainingLockedAssets;
    }
}
