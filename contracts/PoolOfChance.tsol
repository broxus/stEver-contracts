// SPDX-License-Identifier: UNLICENSED
pragma ever-solidity >= 0.62.0;

pragma AbiHeader time;
pragma AbiHeader expire;
pragma AbiHeader pubkey;

import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";

import "broxus-ton-tokens-contracts/contracts/interfaces/ITokenRoot.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/ITokenWallet.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/IAcceptTokensMintCallback.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import {ErrorCodesPoolOfChance} from "./utils/ErrorCodes.tsol";
import {IPoolOfChanceCallback} from "./interfaces/IPoolOfChanceCallback.tsol";
import {IPoolOfChance} from "./interfaces/IPoolOfChance.tsol";

import {IStEverVault} from "./interfaces/IStEverVault.tsol";
import {PoolOfChanceBase} from "./base/PoolOfChanceBase.tsol";
import {PoolOfChanceGas} from "./utils/Gas.tsol";
import {PrizeTokenRewardType} from "./utils/Constants.tsol";

contract PoolOfChance is
    PoolOfChanceBase,
    IAcceptTokensMintCallback,
    IAcceptTokensTransferCallback
{
    constructor(
        address _owner,
        address _stTokenRoot,
        address _stEverVault,
        address _prizeTokenRoot,
        uint128 _minDepositValue,
        uint128 _minDepositValueForReward,
        uint32 _depositsAmountForReward,
        uint32 _rewardPeriod,
        uint128 _poolFeeNumerator,
        uint128 _fundFeeNumerator,
        address _poolFeeReceiverAddress,
        address _fundAddress,
        uint128 _withdrawFee,
        uint8 _prizeTokenRewardType,
        optional(uint128) _prizeTokenRewardValue,
        uint128 _prizeTokenNoRewardValue
    ) public {
        require(_minDepositValue >= _withdrawFee, ErrorCodesPoolOfChance.MIN_DEPOSIT_VALUE_IS_LESS_THAN_FEE);
        require(_minDepositValueForReward >= _minDepositValue, ErrorCodesPoolOfChance.REWARD_DEPOSIT_IS_LESS_THAN_MIN_DEPOSIT);
        tvm.rawReserve(PoolOfChanceGas.POOL_MIN_BALANCE, 0);
        tvm.accept();

        setOwnership(_owner);

        stEverVault = _stEverVault;
        stTokenRoot = _stTokenRoot;
        prizeTokenRoot = _prizeTokenRoot;

        minDepositValue = _minDepositValue;
        minDepositValueForReward = _minDepositValueForReward;

        rewardPeriod = _rewardPeriod;
        poolFeeNumerator = _poolFeeNumerator;
        fundFeeNumerator = _fundFeeNumerator;
        poolFeeReceiverAddress = _poolFeeReceiverAddress;
        fundAddress = _fundAddress;

        depositsAmountForReward = _depositsAmountForReward;

        withdrawFee = _withdrawFee;

        rewardTimestamp = now + rewardPeriod;

        prizeTokenRewardType = _prizeTokenRewardType;
        if (_prizeTokenRewardType == PrizeTokenRewardType.FIXED_REWARD) {
            prizeTokenRewardValue = _prizeTokenRewardValue.hasValue() ? _prizeTokenRewardValue : 0;
        }
        prizeTokenNoRewardValue = _prizeTokenNoRewardValue;

        ITokenRoot(stTokenRoot)
            .deployWallet{
                value: PoolOfChanceGas.WALLET_DEPLOY_VALUE,
                flag: MsgFlag.SENDER_PAYS_FEES,
                callback: PoolOfChanceBase.onTokenWallet,
                bounce: false
            }(address(this), PoolOfChanceGas.WALLET_DEPLOY_GRAMS_VALUE);

        ITokenRoot(prizeTokenRoot)
            .deployWallet{
                value: PoolOfChanceGas.WALLET_DEPLOY_VALUE,
                flag: MsgFlag.SENDER_PAYS_FEES,
                callback: PoolOfChanceBase.onTokenWallet,
                bounce: false
            }(address(this), PoolOfChanceGas.WALLET_DEPLOY_GRAMS_VALUE);

        emit PoolDeployed();

        owner.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS
        });
    }

    function onAcceptTokensTransfer(
        address /*_tokenRoot*/,
        uint128 _amount,
        address /*_sender*/,
        address /*_senderWallet*/,
        address _remainingGasTo,
        TvmCell /*_payload*/
    )
        override
        external
        reserve()
    {
        require(msg.sender == prizeTokenWallet, ErrorCodesPoolOfChance.NOT_ROOT_WALLET);

        totalPrizeTokenSupply += _amount;

        emit PrizeTokenReservesSync(totalPrizeTokenSupply);

        _remainingGasTo.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS
        });
    }

    function deposit(
        uint128 _amount,
        uint64 _nonce
    )
        override
        external
        reserve()
        notLocked
    {
        require(msg.value >= _amount + PoolOfChanceGas.MIN_CALL_VALUE, ErrorCodesPoolOfChance.NOT_ENOUGH_VALUE);
        require(!pendingDeposits.exists(_nonce), ErrorCodesPoolOfChance.NONCE_ALREADY_EXISTS);
        require(_amount >= minDepositValue, ErrorCodesPoolOfChance.BAD_DEPOSIT_AMOUNT);
        require(stats.activeDepositsAmount < depositsAmountForReward, ErrorCodesPoolOfChance.POOL_IS_FULL);
        require(now < rewardTimestamp, ErrorCodesPoolOfChance.END_OF_ROUND);

        optional(uint128) currentDepOpt = depositsData.fetch(msg.sender);
        uint128 newDeposit = _amount;
        uint128 currentDep;
        if (currentDepOpt.hasValue()) {
            currentDep = currentDepOpt.get();
            newDeposit += currentDep;

            if (currentDep < minDepositValueForReward && newDeposit >= minDepositValueForReward) {
                stats.inactiveDepositsAmount -= 1;
                stats.activeDepositsAmount += 1;
                stats.activeUsers.push(msg.sender);
            }
        } else {
            if (newDeposit >= minDepositValueForReward) {
                stats.activeDepositsAmount += 1;
                stats.activeUsers.push(msg.sender);
            } else {
                stats.inactiveDepositsAmount += 1;
            }
        }
        require(
            stats.inactiveDepositsAmount + depositsAmountForReward <= MAX_POOL_CAPACITY,
            ErrorCodesPoolOfChance.TOO_MUCH_INACTIVE_DEPOSITS
        );

        totalSupply += _amount;

        depositsData[msg.sender] = newDeposit;
        pendingDeposits[_nonce] = msg.sender;

        IStEverVault(stEverVault).deposit{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED
        }(
            _amount,
            _nonce
        );
    }

    function onAcceptTokensMint(
        address /* _tokenRoot */,
        uint128 _amount,
        address /* _remainingGasTo */,
        TvmCell _payload
    )
        external
        override
        reserve()
    {
        require(msg.sender == stEverWallet, ErrorCodesPoolOfChance.NOT_ROOT_WALLET);

        totalStSupply += _amount;

        (uint64 nonce) = _payload.toSlice().decode(uint64);
        address user = pendingDeposits[nonce];
        delete pendingDeposits[nonce];

        emit Deposit(
            user,
            depositsData[user],
            _amount,
            totalSupply,
            totalStSupply,
            nonce
        );

        IPoolOfChanceCallback(user).onDepositSuccess{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED,
            bounce: false
        }(_amount, nonce);
    }

    function withdraw() override external locked {
        optional(uint128) depositDataOpt = depositsData.fetch(msg.sender);
        require(depositDataOpt.hasValue(), ErrorCodesPoolOfChance.NOT_ACTIVE_USER);
        require(msg.value >= PoolOfChanceGas.WITHDRAW_VALUE, ErrorCodesPoolOfChance.NOT_ENOUGH_VALUE);

        uint128 depositData = depositDataOpt.get();
        uint128 reward = msg.sender == stats.rewardAssignee ? stats.reward : 0;
        uint128 withdrawal = math.max(depositData + reward, withdrawFee) - withdrawFee;

        uint128 prizeTokenReward;
        if (reward > 0) {
            prizeTokenReward = prizeTokenRewardType == PrizeTokenRewardType.EQUAL_TO_EVER_REWARD
                ? reward
                : prizeTokenRewardValue.get();
        } else if (depositData >= minDepositValueForReward && stats.reward > 0) {
            prizeTokenReward = prizeTokenNoRewardValue;
        }

        require(
            everReserves >= withdrawal && totalPrizeTokenSupply >= prizeTokenReward,
            ErrorCodesPoolOfChance.NOT_ENOUGH_FUNDS
        );

        delete depositsData[msg.sender];
        totalSupply -= depositData;
        everReserves -= withdrawal;
        totalPrizeTokenSupply -= prizeTokenReward;
        if (reward > 0) {
            stats.reward = 0;
        }
        if (depositData >= minDepositValueForReward) {
            stats.activeDepositsAmount -= 1;
        } else {
            stats.inactiveDepositsAmount -= 1;
        }

        if (prizeTokenReward > 0) {
            TvmCell empty;
            ITokenWallet(prizeTokenWallet)
                .transfer{
                    value: PoolOfChanceGas.TRANSFER_VALUE,
                    flag: MsgFlag.SENDER_PAYS_FEES
                }(
                    prizeTokenReward,
                    msg.sender,
                    PoolOfChanceGas.WALLET_DEPLOY_GRAMS_VALUE,
                    msg.sender,
                    true,
                    empty
            );
        }

        emit Withdrawal(
            msg.sender,
            depositData,
            reward,
            totalSupply,
            withdrawFee,
            withdrawal
        );

        emit EverReservesSync(everReserves);

        emit PrizeTokenReservesSync(totalPrizeTokenSupply);

        tvm.rawReserve(everReserves + PoolOfChanceGas.POOL_MIN_BALANCE, 0);

        msg.sender.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED,
            bounce: false
        });
    }

    function calculateReward()
        override
        external
        reserve()
        notLocked
    {
        require(msg.value >= PoolOfChanceGas.MIN_CALL_VALUE, ErrorCodesPoolOfChance.NOT_ENOUGH_VALUE);
        require(now >= rewardTimestamp, ErrorCodesPoolOfChance.TOO_SOON_TO_CALCULATE_REWARD);

        tempRemainingGasTo = msg.sender;

        IStEverVault(stEverVault)
            .getDetails{
                value: 0,
                flag: MsgFlag.ALL_NOT_RESERVED,
                callback: PoolOfChance.onStEverVaultDetails,
                bounce: false
            }();
    }

    function onStEverVaultDetails(IStEverVault.Details _details) external notLocked {
        require (msg.sender == stEverVault, ErrorCodesPoolOfChance.NOT_ST_EVER_VAULT);

        isLocked = true;

        rnd.shuffle();

        if (stats.activeDepositsAmount >= depositsAmountForReward) {

            uint128 stAmountForTotalSupply = _getStEverAmountFor(totalSupply, _details);
            uint128 stReward = totalStSupply - stAmountForTotalSupply;
            uint128 reward = _getEverAmountFor(stReward, _details);

            uint128 totalFee = math.muldivc(reward, poolFeeNumerator + fundFeeNumerator, DENOMINATOR);
            uint128 poolFee = math.muldivc(totalFee, poolFeeNumerator, poolFeeNumerator + fundFeeNumerator);
            uint128 fundFee = totalFee - poolFee;

            uint256 randomIdx = rnd.next(stats.activeDepositsAmount);

            uint128 rewardWithoutFee = reward - totalFee;
            stats.rewardAssignee = stats.activeUsers[randomIdx];
            stats.reward += rewardWithoutFee;

            emit AssignReward(
                stats.rewardAssignee,
                rewardWithoutFee,
                poolFee,
                fundFee,
                stReward,
                everReserves
            );

            uint128 totalPoolFee = poolFee + stats.accPoolFee;
            uint128 totalFundFee = fundFee + stats.accFundFee;

            if (totalPoolFee > 0 && everReserves >= totalPoolFee && poolFeeReceiverAddress.value != 0) {
                everReserves -= totalPoolFee;
                stats.accPoolFee = 0;

                poolFeeReceiverAddress.transfer({
                    value: totalPoolFee,
                    flag: MsgFlag.SENDER_PAYS_FEES,
                    bounce: false
                });
            } else {
                stats.accPoolFee = totalPoolFee;
            }

            if (totalFundFee > 0 && everReserves >= totalFundFee && fundAddress.value != 0) {
                everReserves -= totalFundFee;
                stats.accFundFee = 0;

                fundAddress.transfer({
                    value: totalFundFee,
                    flag: MsgFlag.SENDER_PAYS_FEES,
                    bounce: false
                });
            } else {
                stats.accFundFee = totalFundFee;
            }
        } else {
            emit CancelRewardAssignment(stats.activeDepositsAmount);
        }
        delete stats.activeUsers;

        tvm.rawReserve(everReserves + PoolOfChanceGas.POOL_MIN_BALANCE, 0);

        IPoolOfChance(address(this)).withdrawAllAssets{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED
        }();
    }

    function upgrade(TvmCell code)
        external
        override
        reserve()
        onlyOwner
    {
        require(msg.value >= PoolOfChanceGas.UPGRADE_POOL, ErrorCodesPoolOfChance.NOT_ENOUGH_VALUE);

        emit PoolUpgraded();

        TvmCell data = abi.encode(PoolOfChanceStorage(
            owner,
            poolFactory,
            stEverVault,

            stEverWallet,
            stTokenRoot,
            prizeTokenWallet,
            prizeTokenRoot,

            depositsAmountForReward,

            everReserves,
            totalSupply,
            totalStSupply,
            totalPrizeTokenSupply,

            minDepositValueForReward,
            minDepositValue,

            rewardTimestamp,
            rewardPeriod,

            fundFeeNumerator,
            poolFeeNumerator,
            fundAddress,
            poolFeeReceiverAddress,

            prizeTokenRewardType,
            prizeTokenRewardValue,
            prizeTokenNoRewardValue,

            withdrawFee,

            tempRemainingGasTo,
            stats,

            depositsData,
            pendingDeposits,

            isLocked
        ));

        tvm.setcode(code);
        tvm.setCurrentCode(code);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(TvmCell _data) private {
        tvm.resetStorage();

        PoolOfChanceStorage data = abi.decode(_data, PoolOfChanceStorage);

        owner = data.owner;
        poolFactory = data.poolFactory;
        stEverVault = data.stEverVault;

        stEverWallet = data.stEverWallet;
        stTokenRoot = data.stTokenRoot;
        prizeTokenWallet = data.prizeTokenWallet;
        prizeTokenRoot = data.prizeTokenRoot;

        depositsAmountForReward = data.depositsAmountForReward;

        everReserves = data.everReserves;
        totalSupply = data.totalSupply;
        totalStSupply = data.totalStSupply;
        totalPrizeTokenSupply = data.totalPrizeTokenSupply;

        minDepositValueForReward = data.minDepositValueForReward;
        minDepositValue = data.minDepositValue;

        rewardTimestamp = data.rewardTimestamp;
        rewardPeriod = data.rewardPeriod;

        fundFeeNumerator = data.fundFeeNumerator;
        poolFeeNumerator = data.poolFeeNumerator;
        fundAddress = data.fundAddress;
        poolFeeReceiverAddress = data.poolFeeReceiverAddress;

        prizeTokenRewardType = data.prizeTokenRewardType;
        prizeTokenRewardValue = data.prizeTokenRewardValue;
        prizeTokenNoRewardValue = data.prizeTokenNoRewardValue;

        withdrawFee = data.withdrawFee;

        tempRemainingGasTo = data.tempRemainingGasTo;
        stats = data.stats;

        depositsData = data.depositsData;
        pendingDeposits = data.pendingDeposits;

        isLocked = data.locked;

        owner.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS
        });
    }
}
