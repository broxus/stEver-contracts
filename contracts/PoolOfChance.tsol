// SPDX-License-Identifier: UNLICENSED
pragma ever-solidity >= 0.62.0;

pragma AbiHeader time;
pragma AbiHeader expire;
pragma AbiHeader pubkey;

import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";

import "broxus-ton-tokens-contracts/contracts/interfaces/ITokenRoot.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/ITokenWallet.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/IAcceptTokensMintCallback.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import {ErrorCodesPoolOfChance} from "./utils/ErrorCodes.tsol";
import {IPoolOfChanceCallback} from "./interfaces/IPoolOfChanceCallback.tsol";
import {IPoolOfChance} from "./interfaces/IPoolOfChance.tsol";

import {IStEverVault} from "./interfaces/IStEverVault.tsol";
import {PoolOfChanceBase} from "./base/PoolOfChanceBase.tsol";
import {PoolOfChanceGas} from "./utils/Gas.tsol";
import {PrizeTokenRewardType} from "./utils/Constants.tsol";

contract PoolOfChance is
    PoolOfChanceBase,
    IAcceptTokensMintCallback,
    IAcceptTokensTransferCallback
{
    constructor(
        address _stTokenRoot,
        address _stEverVault,
        address _prizeTokenRoot,
        uint128 _minDepositValue,
        uint128 _minDepositValueForReward,
        uint32 _depositsAmountForReward,
        uint32 _rewardPeriod,
        uint128 _poolFeeNumerator,
        uint128 _fundFeeNumerator,
        address _poolFeeReceiverAddress,
        address _fundAddress,
        uint128 _withdrawFee,
        uint8 _prizeTokenRewardType,
        optional(uint128) _prizeTokenRewardValue,
        uint128 _prizeTokenNoRewardValue,
        address _remainingGasTo
    ) public {
        tvm.rawReserve(PoolOfChanceGas.POOL_MIN_BALANCE, 0);
        tvm.accept();

        stEverVault = _stEverVault;
        stTokenRoot = _stTokenRoot;
        prizeTokenRoot = _prizeTokenRoot;

        minDepositValue = _minDepositValue;
        minDepositValueForReward = _minDepositValueForReward;

        rewardPeriod = _rewardPeriod;
        poolFeeNumerator = _poolFeeNumerator;
        fundFeeNumerator = _fundFeeNumerator;
        poolFeeReceiverAddress = _poolFeeReceiverAddress;
        fundAddress = _fundAddress;

        depositsAmountForReward = _depositsAmountForReward;

        withdrawFee = _withdrawFee;

        rewardTimestamp = now + rewardPeriod;

        prizeTokenRewardType = _prizeTokenRewardType;
        if (_prizeTokenRewardType == PrizeTokenRewardType.FIXED_REWARD) {
            prizeTokenRewardValue = _prizeTokenRewardValue.hasValue() ? _prizeTokenRewardValue : 0;
        }
        prizeTokenNoRewardValue = _prizeTokenNoRewardValue;

        ITokenRoot(stTokenRoot)
            .deployWallet{
                value: PoolOfChanceGas.WALLET_DEPLOY_VALUE,
                flag: MsgFlag.SENDER_PAYS_FEES,
                callback: PoolOfChanceBase.onTokenWallet,
                bounce: false
            }(address(this), PoolOfChanceGas.WALLET_DEPLOY_GRAMS_VALUE);

        ITokenRoot(prizeTokenRoot)
            .deployWallet{
                value: PoolOfChanceGas.WALLET_DEPLOY_VALUE,
                flag: MsgFlag.SENDER_PAYS_FEES,
                callback: PoolOfChanceBase.onTokenWallet,
                bounce: false
            }(address(this), PoolOfChanceGas.WALLET_DEPLOY_GRAMS_VALUE);

        emit PoolDeployed();

        _remainingGasTo.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS
        });
    }

    function onAcceptTokensTransfer(
        address /*_tokenRoot*/,
        uint128 _amount,
        address /*_sender*/,
        address /*_senderWallet*/,
        address _remainingGasTo,
        TvmCell /*_payload*/
    )
        override
        external
        reserve()
    {
        require(msg.sender == prizeTokenWallet, ErrorCodesPoolOfChance.NOT_ROOT_WALLET);

        totalPrizeTokenSupply += _amount;

        emit PrizeTokenReservesSync(totalPrizeTokenSupply);

        _remainingGasTo.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS
        });
    }

    function deposit(
        uint128 _amount,
        uint64 _nonce
    )
        override
        external
        reserve()
        notLocked
    {
        require(msg.value >= _amount + PoolOfChanceGas.MIN_CALL_VALUE, ErrorCodesPoolOfChance.NOT_ENOUGH_VALUE);
        require(!pendingDeposits.exists(_nonce), ErrorCodesPoolOfChance.NONCE_ALREADY_EXISTS);
        require(_amount >= minDepositValue, ErrorCodesPoolOfChance.BAD_DEPOSIT_AMOUNT);
        require(now < rewardTimestamp, ErrorCodesPoolOfChance.END_OF_ROUND);

        uint128 n;
        for ((, DepositData depositData): depositsData) {
            if (depositData.deposit >= minDepositValueForReward) {
                n++;
            }
        }
        require(
            n < depositsAmountForReward || depositsData.exists(msg.sender),
            ErrorCodesPoolOfChance.DEPOSITS_POOL_IS_FULL
        );

        totalSupply += _amount;

        if (!depositsData.exists(msg.sender)) {
            depositsData[msg.sender] = DepositData(_amount, 0, now);
        } else {
            DepositData depositData = depositsData[msg.sender];
            if (depositData.deposit < minDepositValueForReward) {
                depositData.depositTime = now;
            }
            depositData.deposit += _amount;

            depositsData[msg.sender] = depositData;
        }

        pendingDeposits[_nonce] = msg.sender;

        IStEverVault(stEverVault).deposit{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED
        }(
            _amount,
            _nonce
        );
    }

    function onAcceptTokensMint(
        address /* _tokenRoot */,
        uint128 _amount,
        address /* _remainingGasTo */,
        TvmCell _payload
    )
        external
        override
        reserve()
    {
        require(msg.sender == stEverWallet, ErrorCodesPoolOfChance.NOT_ROOT_WALLET);

        totalStSupply += _amount;

        (uint64 nonce) = _payload.toSlice().decode(uint64);
        address user = pendingDeposits[nonce];
        delete pendingDeposits[nonce];

        DepositData data = depositsData[user];
        emit Deposit(
            user,
            data.deposit,
            _amount,
            data.depositTime,
            totalSupply,
            totalStSupply
        );

        IPoolOfChanceCallback(user).onDepositSuccess{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED,
            bounce: false
        }(_amount, nonce);
    }

    function withdraw() override external locked {
        require(depositsData.exists(msg.sender), ErrorCodesPoolOfChance.NOT_ACTIVE_USER);
        require(msg.value >= PoolOfChanceGas.WITHDRAW_VALUE, ErrorCodesPoolOfChance.NOT_ENOUGH_VALUE);

        DepositData depositData = depositsData[msg.sender];
        uint128 withdrawal = math.max(depositData.deposit + depositData.reward, withdrawFee) - withdrawFee;

        uint128 prizeTokenReward;
        if (depositData.reward > 0) {
            prizeTokenReward = prizeTokenRewardType == PrizeTokenRewardType.EQUAL_TO_EVER_REWARD
                ? depositData.reward
                : prizeTokenRewardValue.get();
        } else {
            prizeTokenReward = prizeTokenNoRewardValue;
        }

        require(
            everReserves >= withdrawal && totalPrizeTokenSupply >= prizeTokenReward,
            ErrorCodesPoolOfChance.NOT_ENOUGH_FUNDS
        );

        tvm.rawReserve(
            math.max(
                PoolOfChanceGas.POOL_MIN_BALANCE,
                address(this).balance - msg.value - withdrawal
            ),
            0
        );

        delete depositsData[msg.sender];
        totalSupply -= depositData.deposit;
        everReserves -= withdrawal;
        totalPrizeTokenSupply -= prizeTokenReward;

        if (prizeTokenReward > 0) {
            TvmCell empty;
            ITokenWallet(prizeTokenWallet)
                .transfer{
                    value: PoolOfChanceGas.TRANSFER_VALUE,
                    flag: MsgFlag.SENDER_PAYS_FEES
                }(
                    prizeTokenReward,
                    msg.sender,
                    PoolOfChanceGas.WALLET_DEPLOY_GRAMS_VALUE,
                    msg.sender,
                    true,
                    empty
            );
        }

        emit Withdrawal(
            msg.sender,
            depositData.deposit,
            depositData.reward,
            totalSupply,
            withdrawFee,
            withdrawal
        );

        emit EverReservesSync(everReserves);

        emit PrizeTokenReservesSync(totalPrizeTokenSupply);

        msg.sender.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED,
            bounce: false
        });
    }

    function calculateReward()
        override
        external
        reserve()
        notLocked
    {
        require(msg.value >= PoolOfChanceGas.MIN_CALL_VALUE, ErrorCodesPoolOfChance.NOT_ENOUGH_VALUE);
        require(now >= rewardTimestamp, ErrorCodesPoolOfChance.TOO_SOON_TO_CALCULATE_REWARD);

        IStEverVault(stEverVault)
            .getDetails{
                value: 0,
                flag: MsgFlag.ALL_NOT_RESERVED,
                callback: PoolOfChance.onStEverVaultDetails,
                bounce: false
            }();
    }

    function onStEverVaultDetails(IStEverVault.Details _details) external notLocked {
        require (msg.sender == stEverVault, ErrorCodesPoolOfChance.NOT_ST_EVER_VAULT);

        isLocked = true;

        rnd.shuffle();
        address[] users;
        for ((address user, DepositData depositData): depositsData) {
            if (depositData.deposit >= minDepositValueForReward) {
                users.push(user);
            }
        }
        uint256 n = users.length;

        if (n >= depositsAmountForReward) {

            uint128 stAmountForTotalSupply = _getStEverAmountFor(totalSupply, _details);
            uint128 stReward = totalStSupply - stAmountForTotalSupply;
            uint128 reward = _getEverAmountFor(stReward, _details);

            uint128 totalFee = math.muldivc(reward, poolFeeNumerator + fundFeeNumerator, DENOMINATOR);
            uint128 poolFee = math.muldivc(totalFee, poolFeeNumerator, poolFeeNumerator + fundFeeNumerator);
            uint128 fundFee = totalFee - poolFee;

            uint256 randomIdx = rnd.next(n);

            uint128 rewardWithoutFee = reward - totalFee;
            depositsData[users[randomIdx]].reward += rewardWithoutFee;

            emit AssignReward(
                users[randomIdx],
                rewardWithoutFee,
                poolFee,
                fundFee,
                stReward,
                everReserves
            );

            uint128 totalPoolFee = poolFee + accPoolFee;
            uint128 totalFundFee = fundFee + accFundFee;

            if (totalPoolFee > 0 && everReserves >= totalPoolFee && poolFeeReceiverAddress.value != 0) {
                everReserves -= totalPoolFee;
                accPoolFee = 0;

                poolFeeReceiverAddress.transfer({
                    value: totalPoolFee,
                    flag: MsgFlag.SENDER_PAYS_FEES,
                    bounce: false
                });
            } else {
                accPoolFee = totalPoolFee;
            }

            if (totalFundFee > 0 && everReserves >= totalFundFee && fundAddress.value != 0) {
                everReserves -= totalFundFee;
                accFundFee = 0;

                fundAddress.transfer({
                    value: totalFundFee,
                    flag: MsgFlag.SENDER_PAYS_FEES,
                    bounce: false
                });
            } else {
                accFundFee = totalFundFee;
            }
        } else {
            emit CancelRewardAssignment(uint128(n));
        }
    }

    function upgrade(TvmCell code)
        external
        override
        reserve()
        onlyPoolFactory
    {
        require(msg.value >= PoolOfChanceGas.UPGRADE_POOL, ErrorCodesPoolOfChance.NOT_ENOUGH_VALUE);

        emit PoolUpgraded();

        TvmCell data = abi.encode(PoolOfChanceStorage(
            poolFactory,
            stEverVault,

            stEverWallet,
            stTokenRoot,
            prizeTokenWallet,
            prizeTokenRoot,

            depositsAmountForReward,

            everReserves,
            totalSupply,
            totalStSupply,
            totalPrizeTokenSupply,

            minDepositValueForReward,
            minDepositValue,

            rewardTimestamp,
            rewardPeriod,

            fundFeeNumerator,
            poolFeeNumerator,
            fundAddress,
            poolFeeReceiverAddress,

            prizeTokenRewardType,
            prizeTokenRewardValue,
            prizeTokenNoRewardValue,

            withdrawFee,

            accFundFee,
            accPoolFee,

            depositsData,
            pendingDeposits,

            isLocked
        ));

        tvm.setcode(code);
        tvm.setCurrentCode(code);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(TvmCell _data) private {
        tvm.resetStorage();

        PoolOfChanceStorage data = abi.decode(_data, PoolOfChanceStorage);

        poolFactory = data.poolFactory;
        stEverVault = data.stEverVault;

        stEverWallet = data.stEverWallet;
        stTokenRoot = data.stTokenRoot;
        prizeTokenWallet = data.prizeTokenWallet;
        prizeTokenRoot = data.prizeTokenRoot;

        depositsAmountForReward = data.depositsAmountForReward;

        everReserves = data.everReserves;
        totalSupply = data.totalSupply;
        totalStSupply = data.totalStSupply;
        totalPrizeTokenSupply = data.totalPrizeTokenSupply;

        minDepositValueForReward = data.minDepositValueForReward;
        minDepositValue = data.minDepositValue;

        rewardTimestamp = data.rewardTimestamp;
        rewardPeriod = data.rewardPeriod;

        fundFeeNumerator = data.fundFeeNumerator;
        poolFeeNumerator = data.poolFeeNumerator;
        fundAddress = data.fundAddress;
        poolFeeReceiverAddress = data.poolFeeReceiverAddress;

        prizeTokenRewardType = data.prizeTokenRewardType;
        prizeTokenRewardValue = data.prizeTokenRewardValue;
        prizeTokenNoRewardValue = data.prizeTokenNoRewardValue;

        withdrawFee = data.withdrawFee;

        accFundFee = data.accFundFee;
        accPoolFee = data.accPoolFee;

        depositsData = data.depositsData;
        pendingDeposits = data.pendingDeposits;

        isLocked = data.locked;
    }
}
