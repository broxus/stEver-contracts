pragma ever-solidity >=0.62.0;

interface IPoolOfChance {

    struct DepositData {
        uint128 deposit;
        uint128 reward;
        uint32 depositTime;
    }

    struct PoolInfo {
        address stEverVault;
        uint128 everReserves;
        uint128 totalSupply;
        address stTokenRoot;
        uint128 totalStSupply;
        address prizeTokenRoot;
        uint128 prizeTokenSupply;
        uint128 minDepositValue;
        uint128 withdrawFee;
    }

    struct RewardInfo {
        uint128 minDepositValueForReward;
        uint32 rewardPeriod;
        uint128 rewardTimestamp;
        uint128 poolFeeNumerator;
        uint128 fundFeeNumerator;
        uint32 depositsAmountForReward;
        uint8 prizeTokenRewardType;
        optional(uint128) prizeTokenRewardValue;
        uint128 prizeTokenNoRewardValue;
    }

    struct PoolOfChanceStorage {
        address owner;
        address stEverVault;

        address stEverWallet;
        address stTokenRoot;
        address prizeTokenWallet;
        address prizeTokenRoot;

        uint32 depositsAmountForReward;

        uint128 everReserves;
        uint128 totalSupply;
        uint128 totalStSupply;
        uint128 totalPrizeTokenSupply;

        uint128 minDepositValueForReward;
        uint128 minDepositValue;

        uint128 rewardTimestamp;
        uint32 rewardPeriod;

        uint128 fundFeeNumerator;
        uint128 poolFeeNumerator;
        address fundAddress;
        address poolFeeReceiverAddress;

        uint8 prizeTokenRewardType;
        optional(uint128) prizeTokenRewardValue;
        uint128 prizeTokenNoRewardValue;

        uint128 withdrawFee;

        uint128 accFundFee;
        uint128 accPoolFee;

        mapping(address => DepositData) depositsData;
        mapping(uint64 => address) pendingDeposits;

        bool locked;
    }


    event UpdateMinDepositValue(uint128 current, uint128 previous);

    event UpdatePoolFeeReceiverAddress(address current, address previous);

    event UpdateFundAddress(address current, address previous);

    event Deposit(address user, uint128 amount, uint128 stAmount, uint32 timestamp, uint128 totalSupply, uint128 totalStSupply);

    event Withdrawal(address user, uint128 amount, uint128 reward, uint128 totalSupply, uint128 withdrawFee, uint128 withdrawal);

    event AssignReward(address assignee, uint128 reward, uint128 poolFee, uint128 fundFee, uint128 stReward, uint128 everReserves);
    event CancelRewardAssignment(uint128 depositsAmount);

    event EverReservesSync(uint128 amount);

    event PrizeTokenReservesSync(uint128 amount);

    event PoolUpgraded();


    function getDepositData(address user) responsible external returns(optional(DepositData));

    function getActiveDepositsAmount() responsible external returns(uint128);

    function getRewardInfo() responsible external returns(IPoolOfChance.RewardInfo);

    function getPoolInfo() responsible external returns(PoolInfo);

    function getPoolFeeReceiverAddress() responsible external returns(address);

    function getFundAddress() responsible external returns(address);

    function isPoolLocked() responsible external returns(bool);


    function setPoolFeeReceiverAddress(address _poolFeeReceiver) external;

    function setFundAddress(address _fundAddress) external;

    function deposit(uint128 _amount, uint64 _nonce) external;

    function withdraw() external;

    function calculateReward() external;

    function withdrawPrizeTokenAssets() external;

    function withdrawRemainingStAssets() external;

    function withdrawRemainingAssets() external;

    function withdrawFees() external;

    function addToEverReserves(uint128 _amount) external;

    function upgrade(TvmCell code) external;
}
