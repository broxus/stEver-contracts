pragma ever-solidity >=0.62.0;
pragma AbiHeader expire;
pragma AbiHeader pubkey;

import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/ITokenRoot.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/ITokenWallet.tsol";



import "./interfaces/IStEverCluster.tsol";
import "./interfaces/IStEverVault.tsol";
import "./interfaces/IDepoolStrategyFactory.tsol";
import "./utils/Gas.tsol";
import "./utils/ErrorCodes.tsol";



contract StEverCluster is IStEverCluster, IAcceptTokensTransferCallback {

    uint32 static _nonce;
    address static stEverVault;
    address static stEverOwner;
    address static clusterOwner;

    uint128 requiredAssurance;
    uint32 maxStrategiesCount;
    uint32 currentVersion;
    address strategyFactory;

    uint128 currentAssurance;
    uint32 currentStrategiesCount;
    ClusterState clusterState;

    address stEverTokenRoot;
    address stEverTokenWallet;

    mapping(address => Strategy) strategies;
    mapping(address => bool) deployedStrategies;

    constructor() public {revert();}

    function _init(
        uint32 _version,
        uint128 _assurance,
        uint32 _maxStrategiesCount,
        address _strategyFactory,
        address _stEverTokenRoot
    ) internal {
        requiredAssurance = _assurance;
        maxStrategiesCount = _maxStrategiesCount;
        currentVersion = _version;
        strategyFactory = _strategyFactory;
        stEverTokenRoot = _stEverTokenRoot;
        clusterState = ClusterState.INITIAL;

        ITokenRoot(stEverTokenRoot).deployWallet{
                value: StEverVaultGas.ST_EVER_WALLET_DEPLOY_VALUE,
                callback: StEverCluster.handleStEverTokenWalletAddress,
                bounce: false
        }(address(this), StEverVaultGas.ST_EVER_WALLET_DEPLOY_GRAMS_VALUE);
    }



    function _reserve() internal pure returns (uint128) {
        return math.max(address(this).balance - msg.value, StEverAccountGas.CONTRACT_MIN_BALANCE);
    }

    modifier onlyStEverVault() {
        require(msg.sender == stEverVault,ErrorCodesCluster.NOT_ST_EVER_VAULT);
        _;
    }
    modifier onlyStEverOwner() {
        require(msg.sender == stEverOwner,ErrorCodesCluster.NOT_ST_EVER_OWNER);
        _;
    }
    modifier onyClusterOwner() {
        require(msg.sender == clusterOwner, ErrorCodesCluster.NOT_CLUSTER_OWNER);
        _;
    }
    modifier stEverOwnerOrClusterOwner() {
        require(msg.sender == stEverOwner || msg.sender == clusterOwner, ErrorCodesCluster.NOT_ST_EVER_OWNER_OR_CLUSTER_OWNER);
        _;
    }
    modifier onyStrategyFactory() {
        require(msg.sender == strategyFactory, ErrorCodesCluster.NOT_STRATEGY_FACTORY);
        _;
    }
    modifier minCallValue() {
        require (msg.value >= StEverVaultGas.MIN_CALL_MSG_VALUE, ErrorCodesCluster.LOW_MSG_VALUE);
        _;
    }

    function handleStEverTokenWalletAddress(address _tokenWallet) public {
        require (msg.sender == stEverTokenRoot, ErrorCodesCluster.NOT_ST_EVER_ROOT);
        stEverTokenWallet = _tokenWallet;
    }

    function deployStrategies(address[] _dePools) override external onyClusterOwner {
        uint128 valueForDeployOneStrategy = ClusterGas.STRATEGY_DEPLOY_VALUE  + ClusterGas.MIN_CALL_VALUE * 2;
        uint128 requiredMsgValue = valueForDeployOneStrategy * uint128(_dePools.length);
        require (msg.value >= requiredMsgValue, ErrorCodesCluster.LOW_MSG_VALUE);
        tvm.rawReserve(_reserve(), 0);

        // TODO: выше мы для каждого депула берем ClusterGas.MIN_CALL_VALUE, а здесь вычитаем назад, не оч понял
        for(address dePool : _dePools) {
            IDepoolStrategyFactory(strategyFactory).deployStrategy{
                value: valueForDeployOneStrategy - ClusterGas.MIN_CALL_VALUE,
                flag: 1,
                bounce: false
            }(dePool);
        }
        clusterOwner.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }

    function onStrategyDeployed(address _strategy) override external onyStrategyFactory {
        tvm.rawReserve(_reserve(), 0);

        deployedStrategies[_strategy] = true;

        emit NewStrategyDeployed(_strategy);

        clusterOwner.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }

    function getValueForRemoveStrategies(uint256 _strategiesCount) internal pure returns (uint128) {
        return uint128(_strategiesCount) * StEverVaultGas.REMOVE_STRATEGY_RESERVE;
    }

    function addStrategies(address[] _strategies) public onyClusterOwner {

        if (currentAssurance < requiredAssurance) {
            revert(ErrorCodesCluster.ASSURANCE_NOT_ENOUGH);
        }

        if (currentStrategiesCount + _strategies.length > maxStrategiesCount) {
            revert(ErrorCodesCluster.STRATEGIES_LIMIT_REACHED);
        }

        uint128 valueForRemoveStrategies = getValueForRemoveStrategies(_strategies.length);
        require (
            msg.value >= _strategies.length * StEverVaultGas.EXPERIMENTAL_FEE + valueForRemoveStrategies + StEverVaultGas.MIN_CALL_MSG_VALUE,
            ErrorCodes.NOT_ENOUGH_VALUE
        );

        // TODO: а зачем мы резервируем здесь? У нас ведь нет экстернал вызовов нигде.
        // Почему не запрашиваем эти эверы там, где нужно? т.е на удалении фактическом
        // Reserve value for deleting strategies in the future
        tvm.rawReserve(address(this).balance - (msg.value - valueForRemoveStrategies), 0);

        for (address strategy : _strategies) {

            if (strategies.exists(strategy)) {
                revert(ErrorCodesCluster.STRATEGY_ALREADY_EXISTS);
            }
            if (!deployedStrategies.exists(strategy)) {
                revert(ErrorCodesCluster.STRATEGY_NOT_DEPLOYED_BY_CLUSTER);
            }

            // TODO: честно говоря не очень понимаю для чего этот промежуточный стейт. Он живет только пока не прилетит колбек от волта и больше нигде не юзается
            // по ощущениям на этом шаге можно ничего не писать
            strategies[strategy] = Strategy({
                state: StrategyState.INITIAL
            });
            currentStrategiesCount++;
        }

        IStEverVault(stEverVault).addStrategies{
            value: uint128(_strategies.length) * StEverVaultGas.EXPERIMENTAL_FEE,
            flag: 1,
            bounce: false
        }(_strategies, clusterOwner, _nonce);

        clusterOwner.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }

    function onStrategiesAdded(address[] _strategies) override external onlyStEverVault {
        tvm.rawReserve(_reserve(), 0);
        uint8 batchSize = 50;

        // TODO: вот эта проверка должна быть в начале цепочки, т.е  на addStrategies выше
        // Иначе получается мы в начале пропустили, записали все в кластер, а потом в конце ебнулось и стратегии застряли в инишл стейте?
        require (_strategies.length <= batchSize, ErrorCodes.MAX_BATCH_SIZE_REACHED);
        for (address strategy : _strategies) {
            strategies[strategy].state = StrategyState.ACTIVE;
        }

        clusterOwner.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }

    // TODO: вот тут бы я требовал приложения всех нужных денег, а не где-то раньше, это же все равно адрес кидает?
    // То что мы резервируем в одном а тратим в друго как-то нехорошо
    function removeStrategies(address[] _strategies) public stEverOwnerOrClusterOwner minCallValue {

        for (address strategy : _strategies) {
            require(strategies.exists(strategy), ErrorCodesCluster.STRATEGY_NOT_EXISTS);
            // TODO: а удалять стратегии в инишл стейте возможно?
            require(strategies[strategy].state == StrategyState.ACTIVE, ErrorCodesCluster.STRATEGY_NOT_IN_ACTIVE_STATE);
        }

        _removeStrategies(_strategies);
    }

    function _removeStrategies(address[] _strategies) internal {
        // make free reserves that were locked when strategies were adding
        tvm.rawReserve(address(this).balance - msg.value - getValueForRemoveStrategies(_strategies.length), 0);

        for (address strategy : _strategies) {
            strategies[strategy].state = StrategyState.REMOVING;
        }

        IStEverVault(stEverVault).removeStrategies{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED,
            bounce: false
        }(_strategies, clusterOwner, _nonce);
    }

    function onPendingStrategyRemove(address[] _strategies) override external onlyStEverVault {
        tvm.rawReserve(_reserve(), 0);

        for (address strategy : _strategies) {
            strategies[strategy].state = StrategyState.PENDING_REMOVE;
        }

        clusterOwner.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }

    function onStrategyRemoved(address _strategy) override external onlyStEverVault {

        delete strategies[_strategy];
        currentStrategiesCount--;
        if (clusterState == ClusterState.REMOVING && currentStrategiesCount == 0) {
            IStEverVault(stEverVault).onClusterRemoved{value: 0.2 ever, bounce: false}(clusterOwner, _nonce);
            if (currentAssurance != 0) {
                TvmCell empty;
                ITokenWallet(stEverTokenWallet).transfer{value: 0.2 ever, bounce: false}(
                    currentAssurance,
                    clusterOwner,
                    0,
                    clusterOwner,
                    false,
                    empty
                );
            }
            clusterOwner.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.DESTROY_IF_ZERO, bounce: false});
            return;
        }

        tvm.rawReserve(_reserve(), 0);
        clusterOwner.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }


    function handleDelegateStrategies(address[] _strategies) override external onlyStEverVault {
        // TODO: снова мув с резервированием заранее
        tvm.rawReserve(address(this).balance - (msg.value - getValueForRemoveStrategies(_strategies.length)), 0);

        address[] handledStrategies;

        for (address strategy : _strategies) {

            if (!strategies.exists(strategy)) {
                strategies[strategy] = Strategy({
                        state: StrategyState.ACTIVE
                });
                deployedStrategies[strategy] = true;
                handledStrategies.push(strategy);
            }
        }

        IStEverVault(stEverVault).onStrategiesDelegationHandled{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED,
            bounce: false
        }(clusterOwner, _nonce, handledStrategies);
    }

    function onRemove() override external onlyStEverVault {
        clusterState = ClusterState.REMOVING;
        address[] strategiesForRemove;

        for ((address strategy, Strategy strategyInfo) : strategies) {
            if (strategyInfo.state != StrategyState.ACTIVE) {
                continue;
            }
            strategiesForRemove.push(strategy);
        }
        _removeStrategies(strategiesForRemove);
    }

    function getDetails() override external responsible returns (Details) {
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} Details(
            _nonce,
            stEverVault,
            stEverOwner,
            clusterOwner,
            requiredAssurance,
            maxStrategiesCount,
            currentVersion,
            strategyFactory,
            currentAssurance,
            currentStrategiesCount,
            clusterState,
            stEverTokenRoot,
            stEverTokenWallet,
            strategies,
            deployedStrategies
        );
    }

    function onAcceptTokensTransfer(
        address,
        uint128 _amount,
        address,
        address,
        address remainingGasTo,
        TvmCell
    ) override external {
        require(msg.sender == stEverTokenWallet, ErrorCodesCluster.NOT_ST_EVER_TOKEN_WALLET);
        tvm.rawReserve(_reserve(), 0);

        currentAssurance += _amount;

        emit AssuranceReceived(_amount, currentAssurance);

        remainingGasTo.transfer({value: 0, flag:MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }

    function setAssurance(uint128 _newRequiredAssurance) override external onlyStEverOwner minCallValue {
        tvm.rawReserve(_reserve(), 0);

        requiredAssurance = _newRequiredAssurance;

        emit SetAssuranceAmount(requiredAssurance);

        stEverOwner.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }
    function freeAssurance() public view returns (uint128) {
        return currentAssurance >= requiredAssurance ? currentAssurance - requiredAssurance : 0;
    }

    function withdrawAssurance(uint128 _amount) override external onyClusterOwner {
        uint128 unlockedAssurance = freeAssurance();

        uint128 amountToWithdraw = math.min(_amount, unlockedAssurance);

        currentAssurance -= amountToWithdraw;

        tvm.rawReserve(_reserve(), 0);
        TvmCell empty;

        ITokenWallet(stEverTokenWallet).transfer{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED,
            bounce: false
        }(
            amountToWithdraw,
            msg.sender,
            0,
            msg.sender,
            true,
            empty
        );

    }

    function upgrade(
        TvmCell _newCode,
        uint32 _newVersion,
        address _sendGasTo
    ) external virtual override onlyStEverVault {


        if (_newVersion == currentVersion) {
            tvm.rawReserve(_reserve(), 0);
            _sendGasTo.transfer({ value: 0, bounce: false, flag: MsgFlag.ALL_NOT_RESERVED });
            return;
        }


        TvmBuilder mainBuilder;
        mainBuilder.store(stEverVault);
        mainBuilder.store(uint8(0));
        mainBuilder.store(_sendGasTo);

        TvmCell dummyPlatformCode;
        mainBuilder.store(dummyPlatformCode);

        TvmBuilder initialData;
        initialData.store(_nonce);
        initialData.store(stEverVault);
        initialData.store(stEverOwner);
        initialData.store(clusterOwner);



        TvmBuilder constructorParams;
        constructorParams.store(_newVersion);
        constructorParams.store(currentVersion);
        constructorParams.store(requiredAssurance);
        constructorParams.store(maxStrategiesCount);
        constructorParams.store(strategyFactory);
        constructorParams.store(stEverTokenRoot);



        mainBuilder.storeRef(initialData);
        mainBuilder.storeRef(constructorParams);

        TvmCell storageData = abi.encode(
            _nonce, //uint32
            stEverVault, //address
            stEverOwner, //address
            clusterOwner, //address

            requiredAssurance, //uint128
            maxStrategiesCount, //uint32
            currentVersion, //uint32
            strategyFactory, //address

            currentAssurance, //uint128
            currentStrategiesCount, //uint32
            clusterState, //ClusterState

            stEverTokenRoot, //address
            stEverTokenWallet, //address

            strategies, //mapping(address => Strategy)
            deployedStrategies //mapping(address => bool)
        );

        mainBuilder.storeRef(storageData);


        // set code after complete this method
        tvm.setcode(_newCode);
        // run onCodeUpgrade from new code
        tvm.setCurrentCode(_newCode);

        onCodeUpgrade(mainBuilder.toCell());
    }

    function onCodeUpgrade(TvmCell _upgrade_data) private {
        tvm.resetStorage();
        tvm.rawReserve(_reserve(), 0);
        TvmSlice s = _upgrade_data.toSlice();

        (,, address sendGasTo,) = s.decode(address,uint8,address, TvmCell);
        TvmSlice initialData = s.loadRefAsSlice();

        (_nonce, stEverVault, stEverOwner, clusterOwner) = initialData.decode(uint32, address, address, address);

        TvmSlice constructorParams = s.loadRefAsSlice();

        (
            uint32 _current_version,
            ,
            uint128 _assurance,
            uint32 _maxStrategiesCount,
            address _strategyFactory,
            address _stEverTokenRoot
        ) = constructorParams.decode(
            uint32,
            uint32,
            uint128,
            uint32,
            address,
            address
        );

        _init(
            _current_version,
            _assurance,
            _maxStrategiesCount,
            _strategyFactory,
            _stEverTokenRoot
        );

        sendGasTo.transfer({value: 0, bounce: false, flag: MsgFlag.ALL_NOT_RESERVED});
    }
}
